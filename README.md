# popRR - recombination estimation from pooled genotyping and sequencing

This tool performs **genetic map** and **recombination rate** estimation from pooled population samples.
Highly similarities regarding the recombination rate were observed comparing this pool-based estimation, and a Haldane derived mapping and recombination rate estimation approach.


![Requirements](https://smct-management.de/wp-content/uploads/2020/04/Minium-Requirements-IATF-16949-1024x384.jpeg.webp)

## Requirements / experimental set up 

- a crossing population beyond F2
- the sampling of a representative number of genotypes for each population ( e.g., in a population of 10,000 siblings, 200 to 500 genotypes should be selected for testing)
- a **reference genome**
- whole genome pool sequencing data with a decent coverage per locus (50x are advised; see https://github.com/mischn-dev/HAFcall if you are planning to reduce sequencing levels to 5 or 10x)
    - one pool per population (or you create additional replications - we advise you to use different genotypes for each replicate created)


##
![Workflow](https://cdn.pixabay.com/photo/2020/06/10/06/25/workflow-5281330_960_720.jpg)

## Workflow 

Perform **trimming** of your sequence data if required and progress with the **alignment**. 
For complex plant genomes like maize, barley, or wheat, we observed *bwa* and *bowtie2* to perform best.

**Filter your** aligned reads thoroughly. The recombination rate estimations depend on this filtering step - we want errors to be reduced to retain higher accuracy:

- secondary alignments
- supplementary alignments
- low-quality alignments
- duplicated fragments

Contrasting to the typical variant calling of homozygote genotypes, we need to make sure the ratio of *reference* to *alternative* base calls is as unbiased as possible.

We will generally expect `REF/ALT` variant calls of `20/30` or `10/40`, contrasting to `2/48` - what we would expect for a homozygote single genotyping.

So it is very crucial to maintain high quality from the alignment and the variant calling, as biases introduced by the alignment might directly impact the accuracy of the recombination rate estimation.

You can filter your aligned bam file by applying 

```
# X = number of threads to use

# filter the alignments - this one works for the alignment flags generated by bwa 
sambamba_v0.8.2 view -t X -h -f bam -p -F "mapping_quality >= 30 and not (unmapped or secondary_alignment or 
supplementary) and not ([XA] != null or [SA] != null) and proper_pair" -o filtered.bam ALIGNED.bam

# remove the duplicates and sort
sambamba_v0.8.2 markdup -r -t X -p filtered.bam sambamba_filtered_markdup.bam

# sort the file by position again - important to do for variant calling
sambamba_v0.8.2 sort -t X -p -o filtered_sorted.bam sambamba_filtered_markdup.bam
```
or using your own script. We observed *sambamba* to be very fast and accurate, so we suggest using this package <https://lomereiter.github.io/sambamba/>

Find further information on filtering by sambamba here <https://github.com/biod/sambamba/wiki/%5Bsambamba-view%5D-Filter-expression-syntax>

*Otherwise, you can also use **samtools** to filter your alignments by using this pipeline:* 

```
# X = number of threads to use

# filter the alignments
samtools view -F 2304 -q 30 -f 1 -@ X -o filtered.bam ALIGNED.bam 
# remove duplicates
samtools markdup -@ X -r filtered.bam filtered_markdup.bam 
# sort by position 
samtools sort -@ X -o filtered_sorted.bam filtered_markdup.bam 
```

What does -F 2034 mean? - have a look here <https://broadinstitute.github.io/picard/explain-flags.html>


### **Variant calling**

If possible, call the variants of *all* pool samples in one run.

The recombination rate estimation for each variant locus depends on the **allelic depth** tag *AD*, so ensure your chosen variant caller supports this output format. *Bcftools* is the option used in the procedure of validating popRR.

The code to generate the variant calls with *bcftools* is:

```
# define the input variables
REF="/RefGenome.fa" 
mydir="StoreFolder" # e.g. ~/Documents

bcftools mpileup -Ov -q 25 -Q 30 -a FORMAT/AD -I -f $REF $mydir/*filtered_sorted.bam | bcftools call -vm -Ov > $mydir/variants.vcf
```

**Additional hints for the SNP calling:**
- if available, use an *SNP reference map*, like <http://ftp.ensemblgenomes.org/pub/plants/release-52/variation/vcf/hordeum_vulgare/>
    - this is helpful to avoid false positive detections and will improve the overall recombination rate accuracy
- exclude Indels, as these tend to have higher false-positive rates



## Variant filtering and data preparation


To fit into the desired data format and filter out low-quality SNPs, the uncompressed variant calling format (*vcf*) files must be processed. 

You can use either `bcftools` or `vcftools` (<http://vcftools.sourceforge.net/>) to complete the task.
Use on of either function:
```
# the vcftools way 
vcftools --vcf variants.vcf --out outfFileName --max-alleles 2 --min-alleles 2 --minQ 40 --extract-FORMAT-info AD

# the bcftools way
bcftools view -m2 -M2 -v snps -o variants_biallele.vcf variants.vcf
bcftools query -i 'QUAL>40' -f '%CHROM\t%POS\t[%AD\t]\n' -o outFileName.vcf variants_biallele.vcf
```


Besides the *Position* (Chromosome and physical position on the reference genome), the *allelic depth AD* is required for each sample.

The final table should look like:
| CHROM | POS  | Sample1  | Sample2 | Sample3 |
| ------- | --- | --- | --- | --- |
chr2 |	268269	|127,98 | 	175,128	|187,119 |
chr2 |	352795	| 133,79	| 190,173	| 214,159 |
chr3 |	556914877 | 116,111 |	133,178 |	159,157 |
chr5 |	582298638 | 120,115	| 157,145 |	147,153|


The names of your *samples* can also look like `/Data/recrate/sample1` instead of `Sample1` - both are fine



## Perform the **recombination rate estimation** and the **genetic map** estimation using popRR functions

You have the choice to run *popRR* either in `julia` or `R`. The result is the same, but the computational time is quite drastically decreased in the `julia` environment (about 20 to 100 times faster)

So our recommendation: use the julia function package - save some energy and resources by smart programming :)

To run the `julia` code, you need to install some required packages.

How it is done is illustrated in this video:

![](https://github.com/mischn-dev/popRR/blob/docs/install_juliaPackages.gif)

Run `using Pkg; Pkg.add(["DataFrames", "Statistics", "CSV", "StatsBase"])` in your terminal after opening `julia`

 **HINT** stating `julia -t 4` will make julia running with 4 threads - this will speed things up 

 chose as many cores as you desire to use or your computer provides


### Running the recombination rate estimation in julia environment by terminal 

3 inputs have to be specified:

1. the path to the *outFileName.vcf* generated previously
2. the window size in megabase pairs (e.g. 10) 
    - genomic windows with a sliding window approach of the specified size will be generated, and a median recombination rate will be calculated for each window
3. the population size for **each** sample in the *outFileName.vcf* file 
    - in the scenario where each population as the *same number of genotypes sampled*, you can also give simply a single value - e.g. 500
        - find an example here: <https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/example/samplelist_1_value_for_all_samples.txt>
    - in the scenario where each population consists of different numbers of genotypes, provide a vector of values with a similar length to numbers sampled - e.g. 
        - find an example here: <https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/example/samplelist_unique_value_for_each_sample.txt>

The code in the `terminal` might look like:

 ![](https://github.com/mischn-dev/popRR/blob/docs/run_popRR_terminal_julia.gif)

```
# 20 threads used to speed up 
julia -t 20 popRR_julia.jl outFileName.vcf 5 300

# works the same way in linux terminal & windows command line
```

The script performs a transformation of the *recombination rate* in accordance to the genotyping depth (number of SNPs) and population size (number of individuals per pool sample)

![Formula](https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/docs/adjustment_formula.jpg)


The code will generate 3 output files;

1. ***RecRate.txt***

| Group | Chr  | pos  | Sample1 | Sample2 | Sample3 |
| ----- | ---- | ---- | ------- | ------- | ------- |
| 1     | chr2 | 20000| 4.39    | 3.81    |  5.78   |
|   2   | chr2 | 50000| 2.54    | 2.68    | 3.01    |
| .. | .. | .. | .. | .. | .. | 
| 60 | chr5 | 7000000 | 2.21 | 0.45 | 3.45 |

| Column name | Description |
| --- | --- |
| Group           | The genomic block, according to chromosome, physical position and the selected window size|
| Chr             | The chromosome the *Group* is located on |
| pos             | The mean Position of SNPs aggregated to a *Group*|
| Sample 1..to..X | The median recombination rate in the *Group*, each sample's value is reported in a seperate column. The name of the column refers to the sample name in the *input* file|

It might happen that you observe an `NA` value for a Group:Sample combination - this means there were no SNPs covered in this region for the particular sample

2. ***Markercount.txt***

3. ***SingleSNPinfo.txt***
