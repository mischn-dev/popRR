# popRR - recombination estimation from pooled genotyping and sequencing

This tool performs **genetic map** and **recombination rate** estimation from pooled population samples.
Highly similarities regarding the recombination rate were observed comparing this pool-based estimation, and a Haldane derived mapping and recombination rate estimation approach.


![Requirements](https://smct-management.de/wp-content/uploads/2020/04/Minium-Requirements-IATF-16949-1024x384.jpeg.webp)

## Requirements / experimental set up 

- a crossing population in generaton F2 and later
- the sampling of a representative number of genotypes for each population ( e.g., in a population of 10,000 siblings, 200 to 500 genotypes should be selected for testing)
    - find further details in 
        *Cochran WG, Wiley J, York N, Chichester •, Brisbane •, Toronto •, et al. Sampling Techniques third edition. 1977*
        or <>
- a **reference genome**
- whole genome pool sequencing data with a decent coverage per locus (50x are advised; see https://github.com/mischn-dev/HAFcall if you are planning to reduce sequencing levels to 5 or 10x)
    - one pool per population (or you create additional replications - we advise you to use different genotypes for each replicate created)


##
![Workflow](https://cdn.pixabay.com/photo/2020/06/10/06/25/workflow-5281330_960_720.jpg)

## Workflow 

Perform **trimming** of your sequence data if required and progress with the **alignment**. 
For complex plant genomes like maize, barley, or wheat, we observed *bwa* and *bowtie2* to perform best.

**Filter your** aligned reads thoroughly. The recombination rate estimations depend on this filtering step - we want errors to be reduced to retain higher accuracy:

- secondary alignments
- supplementary alignments
- low-quality alignments
- duplicated fragments

**should be removed**


Contrasting to the typical variant calling of homozygote genotypes, we need to make sure the detected ratio of *reference* to *alternative* base calls is as unbiased as possible. I

Ideally, the observed allele distribution is similar to the true distribution

Generally `REF/ALT` variant calls of `20/30` or `10/40`, contrasting to `2/48` are expected - the latter we would expect when genotyping homozygote single individuals.

So it is very crucial to maintain high quality from the alignment and the variant calling, as biases introduced by the alignment might directly impact the accuracy of the recombination rate estimation.

You can filter your aligned bam file by applying 

```
# X = number of threads to use

# filter the alignments - this one works for the alignment flags generated by bwa 
sambamba_v0.8.2 view -t X -h -f bam -p -F "mapping_quality >= 30 and not (unmapped or secondary_alignment or 
supplementary) and not ([XA] != null or [SA] != null) and proper_pair" -o filtered.bam ALIGNED.bam

# remove the duplicates and sort
sambamba_v0.8.2 markdup -r -t X -p filtered.bam sambamba_filtered_markdup.bam

# sort the file by position again - important to do for variant calling
sambamba_v0.8.2 sort -t X -p -o filtered_sorted.bam sambamba_filtered_markdup.bam
```
or using your own script. We observed *sambamba* to be very fast and accurate, so we suggest using this package <https://lomereiter.github.io/sambamba/>

Find further information on filtering by sambamba here <https://github.com/biod/sambamba/wiki/%5Bsambamba-view%5D-Filter-expression-syntax>

*Otherwise, you can also use **samtools** to filter your alignments by using this pipeline:* 

```
# X = number of threads to use

# filter the alignments
samtools view -F 2304 -q 30 -f 1 -@ X -o filtered.bam ALIGNED.bam 
# remove duplicates
samtools markdup -@ X -r filtered.bam filtered_markdup.bam 
# sort by position 
samtools sort -@ X -o filtered_sorted.bam filtered_markdup.bam 
```

What does -F 2034 mean? - have a look here <https://broadinstitute.github.io/picard/explain-flags.html>


### **Variant calling**

If possible, call the variants of *all* pool samples in one run. 

Why? Because variant callers become more powerful as more data is provided. Multisample variant calling >> single sample variant valling

The recombination rate estimation for each variant locus depends on the **allelic depth** tag *AD*, so ensure your chosen variant caller supports this output format. *Bcftools* is the option used in the procedure of validating popRR.

The code to generate the variant calls using *bcftools* is:

```
# define the input variables
REF="/RefGenome.fa" 
mydir="StoreFolder" # e.g. ~/Documents

bcftools mpileup -Ov -q 25 -Q 30 -a FORMAT/AD -I -f $REF $mydir/*filtered_sorted.bam | bcftools call -vm -Ov > $mydir/variants.vcf
```

**Additional hints for the SNP calling:**
- if available, use an *SNP reference map*, like <http://ftp.ensemblgenomes.org/pub/plants/release-52/variation/vcf/hordeum_vulgare/>
    - this is helpful to avoid false positive detections and will improve the overall recombination rate accuracy
    - use the `--regions-file` flag to include a *bed* position file in the variant calling
        - find more information here <https://samtools.github.io/bcftools/bcftools.html#common_options>
- exclude Indels, as these tend to have higher false-positive rates



## Variant filtering and data preparation


To fit into the desired data format and filter out low-quality SNPs, the variant calling format (*vcf*) files must be processed. 

You can use either `bcftools` or `vcftools` (<http://vcftools.sourceforge.net/>) to complete the task.
Use one of either function:
```
# the vcftools way 
vcftools --vcf variants.vcf --out outfFileName --max-alleles 2 --min-alleles 2 --minQ 40 --extract-FORMAT-info AD

# the bcftools way
bcftools view -m2 -M2 -v snps -o variants_biallele.vcf variants.vcf
bcftools query -i 'QUAL>40' -f '%CHROM\t%POS\t[%AD\t]\n' -o outFileName.vcf variants_biallele.vcf
```


Besides the *Position* (Chromosome and physical position on the reference genome), the *allelic depth AD* is required for each sample.

The final table should look like:
| CHROM | POS  | Sample1  | Sample2 | Sample3 | .. |
| ------- | --- | --- | --- | --- | --- |
chr2 |	268269	|127,98 | 	175,128	|187,119 | .. |
chr2 |	352795	| 133,79	| 190,173	| 214,159 | .. |
chr3 |	556914877 | 116,111 |	133,178 |	159,157 | .. |
chr5 |	582298638 | 120,115	| 157,145 |	147,153| .. |


The names of your *samples* can also look like `/Data/recrate/sample1` instead of `Sample1` - both are fine



## Perform the **recombination rate estimation** and the **genetic map** estimation using popRR functions

You have the choice to run *popRR* either in `julia` or `R`. The result is the same, but the computational time is quite drastically decreased in the `julia` environment (about 20 to 100 times faster)

### **3 inputs have to be specified (*in this exact order*):**

1. the path to the *outFileName.vcf* generated previously
2. the window size in megabase pairs (e.g. 10) 
    - genomic windows with a sliding window approach of the specified size will be generated, and a median recombination rate will be calculated for each window
3. the population size for **each** sample in the *outFileName.vcf* file 
    - in the scenario where each population as the *same number of genotypes sampled*, you can also give simply a single value - e.g. 500
        - find an example here: <https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/example/samplelist_1_value_for_all_samples.txt>
    - in the scenario where each population consists of different numbers of genotypes, provide a vector of values with a similar length to numbers sampled - e.g. 
        - find an example here: <https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/example/samplelist_unique_value_for_each_sample.txt>


### Get started with julia 

To run the `julia` code, you need to install some required packages.

How the package installation is done is illustrated in this video:

![](https://github.com/mischn-dev/popRR/blob/docs/install_juliaPackages.gif)

Run `using Pkg; Pkg.add(["DataFrames", "Statistics", "CSV", "StatsBase"])` in your terminal after opening `julia`

 **HINT** stating `julia -t 4` will make julia running with 4 threads - this will speed things up 

 chose as many cores as you desire to use or your computer provides


### Perform the recombination rate estimation in `julia` environment via shell 


The code in the `terminal` might look like:

 ![](https://github.com/mischn-dev/popRR/blob/docs/run_popRR_terminal_julia.gif)

```
# 20 threads used to speed up 
julia -t 20 popRR_julia.jl ./outFileName.vcf 5 ./samplelist_unique_value_for_each_sample.txt

# works the same way in linux terminal & windows command line
```

The script performs a transformation of the *recombination rate* in accordance to the genotyping depth (number of SNPs) and population size (number of individuals per pool sample)

![Formula](https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/docs/adjustment_formula.jpg)


### Perform the recombination rate estimation in the `R` environment via `Rscript`

The `Rscript` version of popRR works 1:1 identical as the `julia` code above 

Just type `Rscript /mnt/d/GeneticMapProject/zz-github/popRR_R.R ../../outFileName.vcf 5 ../../samplelist_unique_value_for_each_sample.txt ` to your shell terminal and execute it


### Perform the recombiation rate estimation in native `R`

- download <https://github.com/mischn-dev/popRR/blob/main/popRR_R_function_only.R>
- open `RStudio` or `R` and load function `popRR` in the global environment
- execute `popRR` by writing:

```
# define the variables
input = "../../outFileName.vcf" # path to file
windowsize = 50 # in MB 
Popsize = "../../sampleList.txt" # population size file location

# run the function and store the output to "result"
result = popRR(input, windowsize, Popsize)

# check out result by 
result$Recrate
result$Markercount
result$SingleSNPinfo
```


## Output 

The code will generate 3 output files in your current work folder (*the information which folder this is will be printed to the screen*);

1. ***RecRate.txt***

    | Group | Chr  | pos  | Sample1 | Sample2 | Sample3 |
    | ----- | ---- | ---- | ------- | ------- | ------- |
    | 1     | chr2 | 20000| 4.39    | 3.81    |  5.78   |
    |   2   | chr2 | 50000| 2.54    | 2.68    | 3.01    |
    | .. | .. | .. | .. | .. | .. | 
    | 60 | chr5 | 7000000 | 2.21 | 0.45 | 3.45 |




2. ***Markercount.txt***

    | Group | Chr  | pos  | Sample1 | Sample2 | Sample3 |
    | ----- | ---- | ---- | ------- | ------- | ------- |
    | 1     | chr2 | 20000| 222    |  220   |  243   |
    |   2   | chr2 | 50000| 95    | 102   | 100    |
    | .. | .. | .. | .. | .. | .. | 
    | 60 | chr5 | 7000000 | 501 | 620 | 488 |

    In *RecRate.txt* and *Markercount.txt*, you might observe `NA` values for a Group:Sample combination - this means there were no SNPs observed in this *Group* for the particular sample




3. ***SingleSNPinfo.txt***

    |Chr |POS	|Readcount	|Ref	|Alt	|GeneticMapPosition |RR	|sample   |
    | ----- | ---- | ---- | ------- |  ------- | --- | --- | --- | 
    | chr2 |	268269	| 225	| 0.5644 | 0.4355	 0.0	| 0.0	| *sample1* |
    | .. | .. | .. | .. | .. | .. | .. | .. | 
    | chr2H |	352927 |	227	 | 0.5726 |	0.4273	|	3.659	| 2.3 | *sample1*
    | .. | .. | .. | .. | .. | .. | .. | .. | 
    | chr2H |	485482145 |	154	 | 0.4289 |	0.5711	|	158.45	| 1.1 | *sample1*
    | .. | .. | .. | .. | .. | .. | .. | .. |
    | .. | .. | .. | .. | .. | .. | .. | .. | 
    | chr2 |	352927	| 221	| 0.5342 | 0.4658| 2.112	| 1.12	| *sample2* |
    | .. | .. | .. | .. | .. | .. | .. | .. | 
    




### Explanation of created output:

| Column name | Description |
| --- | --- |
| Group           | The genomic block, according to chromosome, physical position and the selected window size [id]|
| Chr             | The chromosome the *Group* is located on |
| pos             | The mean Position of SNPs aggregated to a *Group* [bp]|
| Sample 1..to..X | The *median recombination rate* or *sum of SNPs* in the *Group*, each sample's value is reported in a separate column. The name of the column refers to the sample name in the *input* file [cM/MB] or [count]|
|.. | **SingleSNPinfo.txt** file:|
|Chr	| The chromosome the SNP is located on |
|POS	| The physical position of the SNP [bp]|
|Readcount	| The number of reads covering this locus [count]|
|Ref	| the allele frequency of the *reference* allele [ *100 = %]|
|Alt	| the allele frequency of the *alternative* allele [ *100 = %]|
|GeneticMapPosition | The genetic position of the SNP [cM] | 
|RR	 | The recombination rate observed for this SNP [cM/MB] |
|sample    | The sample in which this information was collected - analog to *Sample 1 ..to..X* [id] |


## What was created and how to interpret the results?

The main results are stored in *RecRate.txt*. Here, the recombination rate in genomic windows of the selected size is stored for each tested population. 
The *recombination rates* are aligned across all samples by the *Group + Chr* identifier. So you can compare the *recombination rate* directly from one sample to another without the need for positional sorting. These results can be plotted to file by `plotRecRate.R`

Supplementary results are stored in *Markercount.txt* and *SingleSNPinfo.txt*.

*Markercount.txt* derived the information of the number of SNPs aggregated together to a *Group*. The median *recombination rate* in *RecRate.txt* was calculated from all these SNPs. 

*SingleSNPinfo.txt* has stored the **raw data**. Each SNPs allele frequency, recombination rate and genetic map position are stored separatly for each sample.


## How to interpret / scale the output?

Although you might have tried to avoid sequencing bias by following the pipeline above, you might end up with values far above your expectations. 

What went wrong? 

By the filtering and cleaning pipeline, we only took care of the inter-sample bias. So all steps performed above were meant to remove technical biases from one sample to the other, so that you can compare all of them to each other, without any problems. 

Still, we might have a genetic map that ranges from 0 to 2,000, 3,000, 20,000 or even 2,000,000 cM, depending on your data. Obviously, these absolute numbers are incorrect. What is correct is the relative values from one sample to another. 

So when you observe **sample1'** *SNP300* genetic position of 2,500 cM you can compare it strait to **sample2'** *SNP300* genetic position, which might be 2,100 cM. So we can say we observed more recombination activity in **sample1** than **sample2**.

Okay, but why were these values not adjusted by the `popRR` function in the first place?

Of course, our goal was to generate an exact 1:1 copy of *Haldane* recombination rate estimates with this pool sequencing approach. But as sequencing results might differ between applied methods, amount of DNA, sequencing depth, and people might treat their data differently, we could not figure out a model to obey for all these variables. 

Therefore, we suggest the following when you want to scale down your recombination rate estimations:

1. Check out the literature and find genetic maps in your species or related species and investigate what is the maximal genetic position reported - e.g. *350 cM*
2. Search in your *SingleSNPinfo.txt* file in column `GeneticMapPosition` for the biggest value. The R code might look like `max(result$SingleSNPinfo$GeneticMapPosition)` - the value might be, e.g. 5940
3. Divide the maximal literature derived value (*350*) by the maximal position value in your table (*5940*) => `350 / 5940 = 0.0589 `
4. The retained value *0.0589* is your correction value - multiply this value to your *recombination rate values* and the *genetic map positions*
    - `result$SingleSNPinfo$GeneticMapPosition = result$SingleSNPinfo$GeneticMapPosition * 0.0589`
    - `result$SingleSNPinfo$RR = result$SingleSNPinfo$RR * 0.0589`
        - You still observe high *recombination rate* values for single SNPs? That's why we focus on the median in genomic windows in *RecRate.txt*
    - `rr2 = apply(results$RecRate[,-c(1:3)], 2, function(x) x * 0.0589); results$RecRate = results$RecRate[,c(1:3)], rr2)`
        - You checked out the result of the adjustment and still found some *Groups* to have *cM/MB* rates beyond 10, maybe 100? That can occur.
            - The most recommended solution to this problem is to increase your genomic window size
            - if only single *Groups* tend to have different values, you might check how many SNPs are located in this group by examining *Markercount.txt*. If indeed only few SNPs are loacted in this *Group*, you can savely remove the recombination rate. Our approach faciliates from many SNP loci tagged and aggregated to *Groups*, so as more SNPs a *Group* has, as more precise the result will be.
                - What is a good cut-off value for SNP count per *Group*?
                    - we cannot give you a solid answer to that, sorry. It depends on the interplay of the read coverage level you chose to sequence and the SNP count. So generally spoken, as higher the per locus sequencing depth, as lower the SNP count per *Group* can become.


### Generating a first overview plot

The script <https://github.com/mischn-dev/popRR/blob/main/generateOverview.R> will create a figure that allows to assess the results quickly

before executing the script, run `install.packages(c("ggplot2", "data.table", "plyr", "gridExtra"))` to install all required packages

The R script is executed again in the shell via `Rscript ../generateOverview.R ./RecRate.txt` 

It will produce a figure as shown below

![examplePlot](https://github.com/mischn-dev/popRR/blob/mischn-dev/popRR/example/RecombinationRate_plot.png)

